#####################################################################
# THIS FILE IS AUTOMATICALLY GENERATED BY UNSTRUCTURED API TOOLS.
# DO NOT MODIFY DIRECTLY
#####################################################################

import os
import inspect
from typing import List

from fastapi import status, FastAPI, File, Form, Request, UploadFile
from slowapi.errors import RateLimitExceeded
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
app = FastAPI()
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

RATE_LIMIT = os.environ.get("PIPELINE_API_RATE_LIMIT", "1/second")

import tempfile
from unstructured.documents.pdf import PDFPage, PDFDocument


import warnings


def partition_oer(filename: str):
    doc = PDFDocument(filename)

    # NOTE(robinson) - The warning we catch comes from the detectron2
    # code. We have an issue to contribute back a fix for that
    with warnings.catch_warnings():
        warnings.simplefilter("ignore")
        doc._read()
        pages = [page for page in doc.pages]

    return pages


import re


BLOCK_TITLE_RE = re.compile(
    r"c. (SIGNIFICANT DUTIES AND RESPONSIBILITIES" r"|COMMENTS ON POTENTIAL)"
)


def clean_block_titles(narrative: str) -> str:
    """Cleans the name of the block from the extracted narrative text"""
    return BLOCK_TITLE_RE.sub("", narrative).strip()


COMMENT_BLOCKS = [
    "character",
    "presence",
    "intellect",
    "leads",
    "develops",
    "achieves",
]


def structure_oer(pages):
    """Creates a dictionary with the extracted elements of the OER"""
    if len(pages) < 2:
        raise ValueError(f"Pages length is {len(pages)}). " "Expected 2 pages.")

    structured_oer = dict()

    first_page = pages[0].elements
    if len(first_page) < 2:
        raise ValueError(
            f"Number of narrative text elements on the "
            f"first page is {len(first_page)}. "
            "Expected at least two."
        )

    duty_description = clean_block_titles(first_page[0].text)
    structured_oer["duty_description"] = duty_description
    structured_oer["rater_comments"] = first_page[-1].text

    second_page = pages[1].elements
    num_sections = len(COMMENT_BLOCKS)

    if len(first_page) < 2:
        raise ValueError(
            f"Number of narrative text elements on the "
            f"second page is {len(second_page)}. "
            f"Expected at least {num_sections}."
        )

    for i, section in enumerate(second_page[:num_sections]):
        key = COMMENT_BLOCKS[i]
        structured_oer[key] = section.text

    structured_oer["intermediate_rater"] = second_page[-2].text

    return structured_oer


def pipeline_api(text):
    tmp = tempfile.NamedTemporaryFile(prefix="tmp_", delete=False)
    tmp.write(text)
    tmp.close()

    pages = partition_oer(tmp.name)
    return structure_oer(pages)


@app.post("/oer/v0.0.1/comments")
@limiter.limit(RATE_LIMIT)
async def pipeline_1(
    request: Request,
    file: UploadFile = File(),
):

    text = file.file.read().decode("utf-8")
    response = pipeline_api(
        text,
    )

    return response


@app.get("/healthcheck", status_code=status.HTTP_200_OK)
@limiter.limit(RATE_LIMIT)
async def healthcheck(request: Request):
    return {"healthcheck": "HEALTHCHECK STATUS: EVERYTHING OK!"}
