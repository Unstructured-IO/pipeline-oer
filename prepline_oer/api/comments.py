#####################################################################
# THIS FILE IS AUTOMATICALLY GENERATED BY UNSTRUCTURED API TOOLS.
# DO NOT MODIFY DIRECTLY
#####################################################################

import os
import inspect
from typing import List

from fastapi import status, FastAPI, File, Form, Request, UploadFile
from slowapi.errors import RateLimitExceeded
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address

limiter = Limiter(key_func=get_remote_address)
app = FastAPI()
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

RATE_LIMIT = os.environ.get("PIPELINE_API_RATE_LIMIT", "1/second")

# pipeline-api
import tempfile
import requests
import json


def partition_oer(filename: str, include_elems=["Text", "Title"]):
    response = requests.post(
        "http://127.0.0.1:8000/layout/pdf",
        files={
            "file": (filename, open(filename, "rb")),
        },
        data={"include_elems": include_elems},
    )
    # NOTE(yuming): return the result from post request as a dictionary
    partition_result = json.loads(response.content.decode("utf-8"))
    return partition_result


import re


BLOCK_TITLE_RE = re.compile(
    r"c. (SIGNIFICANT DUTIES AND RESPONSIBILITIES" r"|COMMENTS ON POTENTIAL)"
)


def clean_block_titles(narrative: str) -> str:
    """Cleans the name of the block from the extracted narrative text"""
    return BLOCK_TITLE_RE.sub("", narrative).strip()


COMMENT_BLOCKS = [
    "character",
    "presence",
    "intellect",
    "leads",
    "develops",
    "achieves",
]


def structure_oer(pages):
    """Creates a dictionary with the extracted elements of the OER"""
    if len(pages) < 2:
        raise ValueError(f"Pages length is {len(pages)}). " "Expected 2 pages.")

    structured_oer = dict()

    first_page = pages[0]["elements"]
    if len(first_page) < 2:
        raise ValueError(
            f"Number of narrative text elements on the "
            f"first page is {len(first_page)}. "
            "Expected at least two."
        )

    duty_description = clean_block_titles(first_page[0]["text"])
    structured_oer["duty_description"] = duty_description
    structured_oer["rater_comments"] = first_page[-1]["text"]

    second_page = pages[1]["elements"]
    num_sections = len(COMMENT_BLOCKS)

    if len(first_page) < 2:
        raise ValueError(
            f"Number of narrative text elements on the "
            f"second page is {len(second_page)}. "
            f"Expected at least {num_sections}."
        )

    for i, section in enumerate(second_page[:num_sections]):
        key = COMMENT_BLOCKS[i]
        structured_oer[key] = section["text"]

    structured_oer["intermediate_rater"] = second_page[-2]["text"]

    return structured_oer


def pipeline_api(text):
    with tempfile.NamedTemporaryFile(prefix="tmp_") as tmp:
        tmp.write(text)
        pages = partition_oer(tmp.name)["pages"]

    return structure_oer(pages)


@app.post("/oer/v0.0.1/comments")
@limiter.limit(RATE_LIMIT)
async def pipeline_1(
    request: Request,
    file: UploadFile = File(),
):

    text = file.file.read().decode("utf-8")

    response = pipeline_api(
        text,
    )

    return response


@app.get("/healthcheck", status_code=status.HTTP_200_OK)
@limiter.limit(RATE_LIMIT)
async def healthcheck(request: Request):
    return {"healthcheck": "HEALTHCHECK STATUS: EVERYTHING OK!"}
