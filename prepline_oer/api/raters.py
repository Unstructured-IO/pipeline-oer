#####################################################################
# THIS FILE IS AUTOMATICALLY GENERATED BY UNSTRUCTURED API TOOLS.
# DO NOT MODIFY DIRECTLY
#####################################################################

import os
from typing import List, Union
from fastapi import status, FastAPI, File, Form, Request, UploadFile, APIRouter
from slowapi.errors import RateLimitExceeded
from slowapi import Limiter, _rate_limit_exceeded_handler
from slowapi.util import get_remote_address
from fastapi.responses import PlainTextResponse
import json
from fastapi.responses import StreamingResponse
from starlette.types import Send
from base64 import b64encode
from typing import Optional, Mapping, Iterator, Tuple
import secrets
from unstructured_inference.inference.layout import (
    process_data_with_model,
    process_file_with_model,
    DocumentLayout,
)
from layoutparser import TextBlock, Rectangle, Layout
import re
from unstructured.cleaners.core import clean_prefix, clean_extra_whitespace
from unstructured.cleaners.core import clean_postfix, replace_unicode_quotes
from collections import defaultdict


limiter = Limiter(key_func=get_remote_address)
app = FastAPI()
app.state.limiter = limiter
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)
router = APIRouter()

RATE_LIMIT = os.environ.get("PIPELINE_API_RATE_LIMIT", "1/second")


# pipeline-api

field_locs = [
    {
        "rated": [20.0, 76.0, 253.0, 100.0],
        "rated_position": [20.0, 453.0, 305.0, 473.0],
        "rater": [20.0, 169.0, 302.0, 193.0],
        "rater_position": [459.0, 169.0, 591.0, 193.0],
        "intermediate": [20.0, 219.0, 302.0, 243.0],
        "intermediate_position": [459.0, 219.0, 591.0, 243.0],
        "senior": [20.0, 269.0, 253.0, 293.0],
        "senior_position": [459.0, 269.0, 591.0, 293.0],
        "duty_description": [20.0, 475.0, 592.0, 565.0],
        "rater_comments": [20.0, 704.0, 592.0, 753.0],
    },
    {
        "character": [165.0, 56.0, 592.0, 107.0],
        "presence": [165.0, 108.0, 592.0, 159.0],
        "intellect": [165.0, 160.0, 592.0, 211.0],
        "leads": [165.0, 212.0, 592.0, 263.0],
        "develops": [165.0, 264.0, 592.0, 315.0],
        "achieves": [165.0, 316.0, 592.0, 367.0],
        "intermediate_rater_comments": [20.0, 379.0, 592.0, 513.0],
        "senior_rater_comments": [175.0, 543.0, 592.0, 700.0],
        "next_assignments": [175.0, 701.0, 592.0, 753.0],
    },
]


def get_textblock(name, loc):
    block = TextBlock(Rectangle(*loc), type=name)
    return block


def get_fixed_layout(loc_d):
    blocks = [get_textblock(name, loc) for name, loc in loc_d.items()]
    fixed_layout = Layout(blocks)
    return fixed_layout


def get_layout(
    filename="",
    file=None,
    model=None,
    fixed_layouts=None,
):
    layout = (
        process_file_with_model(filename, model, fixed_layouts=fixed_layouts)
        if file is None
        else process_data_with_model(file, model, fixed_layouts=fixed_layouts)
    )
    return layout


def partition_oer(layout: DocumentLayout):
    pages = []
    for page in layout.pages:
        pages.append({"elements": [el.to_dict() for el in page.elements]})
    return {"pages": pages}


BLOCK_TITLE_PATTTERN = (
    r"c. (SIGNIFICANT DUTIES AND RESPONSIBILITIES|COMMENTS ON POTENTIAL):?"
)

NAME_OCR_WHITESPACE = r"\.?_*[\n\r\s]*"


PROMPTS = {
    "rater": r"a1\. NAME OF RATER \(Last, First, Middle Initial\)",
    "rater_position": r"a4\. POSITION",
    "intermediate": r"b1\. NAME OF INTERMEDIATE RATER \(Last, First, Middle Initial\)",
    "intermediate_position": r"b4\. POSITION",
    "senior": r"c1\. NAME OF SENIOR RATER \(Last, First, Middle Initial\)",
    "senior_position": r"c4\. POSITION",
    "rated_position": r"a\. PRINCIPAL DUTY TITLE",
    "duty_description": r"c\. SIGNIFICANT DUTIES AND RESPONSIBILITIES",
    "rater_comments": r"Comments:",
    "senior_rater_comments": r"c\. COMMENTS ON POTENTIAL:",
    "next_assignments": [
        r"d\. List 3 future SUCCESSIVE assignments for which this Officer is best suited:",
        r"\. List 3 future SUCCESSIVE assignments for which this Officer is best suited:",
        r"d\. List 3 future SUCCESSIVE assignments for which this Officer is bestsuited:",
        r"\. List 3 future SUCCESSIVE assignments for which this Officer is bestsuited:",
    ],
}

PROMPTS = defaultdict(str, **PROMPTS)

DESCRIPTIONS = {
    "character": (
        "Adherence to Army Values, Empathy, and Warrior Ethos/Service Ethos and Discipline. "
        "Fully supports SHARP, EO, and EEO."
    ),
    "presence": "Military and Professional Bearing, Fitness, Confident, Resilient",
    "intellect": "Mental Agility, Sound Judgment, Innovation, Interpersonal Tact, Expertise",
    "leads": (
        "Leads Others, Builds Trust, Extends Influence beyond the Chain of Command, Leads "
        "by Example, Communicates"
    ),
    "develops": (
        "Creates a positive command/workplace environment/Fosters Esprit de Corps, Prepares "
        "Self, Develops Others, Stewards the Profession"
    ),
    "achieves": "Gets Results",
}


def clean_all_prompts(typ, text):
    if isinstance(PROMPTS[typ], str):
        prompts = [PROMPTS[typ]]
    else:
        prompts = PROMPTS[typ]
    cleaned_text = text
    for prompt in prompts:
        cleaned_text = clean_prefix(cleaned_text, prompt)
        cleaned_text = clean_postfix(cleaned_text, prompt)
    cleaned_text = clean_extra_whitespace(cleaned_text)
    cleaned_text = replace_unicode_quotes(cleaned_text)
    return cleaned_text


def structure_oer(pages):
    """Creates a dictionary with the extracted elements of the OER.
    Input is a list of dictionaries,
    each dictionary contains raw information of a page as extracted from PDF parsing.
    Output is a dictionary that includes structured extracted information from the OER.
    """
    if len(pages) < 2:
        raise ValueError(f"Pages length is {len(pages)}. " "Expected 2 pages.")

    structured_oer = dict()

    flat_elements = {
        el["type"]: clean_all_prompts(el["type"], el["text"])
        for page in pages
        for el in page["elements"]
    }

    structured_oer["duty_description"] = flat_elements["duty_description"]
    structured_oer["rater"] = {
        "name": flat_elements["rater"],
        "position": flat_elements["rater_position"],
        "comments": flat_elements["rater_comments"],
        "sections": {k: v for k, v in flat_elements.items() if k in DESCRIPTIONS},
    }
    structured_oer["senior_rater"] = {
        "name": flat_elements["senior"],
        "position": flat_elements["senior_position"],
        "comments": flat_elements["senior_rater_comments"],
        "next_assignment": [
            clean_extra_whitespace(text)
            for text in flat_elements["next_assignments"].split(";")
        ],
    }

    structured_oer["intermediate_rater"] = {
        "name": flat_elements["intermediate"],
        "position": flat_elements["intermediate_position"],
        "comments": flat_elements["intermediate_rater_comments"],
    }
    structured_oer["rated"] = flat_elements["rated"]
    structured_oer["rated_position"] = flat_elements["rated_position"]
    structured_oer["rater"]["sections"] = {
        section: flat_elements[section] for section in DESCRIPTIONS
    }

    return structured_oer


box_centers = [
    {
        (56.905, 360.375): ("referred", "Referred"),
        (132.379, 360.375): ("comments", "Yes, comments are attached"),
        (244.392, 360.375): ("comments", "No"),
        (153.943, 382.075): ("supplementary_review", "Yes"),
        (189.284, 382.075): ("supplementary_review", "No"),
        (367.786, 674.25): ("completed_form_received", "Yes"),
        (397.736, 674.25): ("completed_form_received", "No"),
        (80.266, 697.5): ("performance", "EXCELS"),
        (177.304, 697.5): ("performance", "PROFICIENT"),
        (274.342, 697.5): ("performance", "CAPABLE"),
        (371.979, 697.5): ("performance", "UNSATISFACTORY"),
    },
    {
        (46.123, 577.375): ("potential", "MOST QUALIFIED"),
        (46.123, 609.15): ("potential", "HIGHLY QUALIFIED"),
        (46.123, 642.475): ("potential", "QUALIFIED"),
        (46.123, 674.25): ("potential", "NOT QUALIFIED"),
    },
]


def point_in_box(point, box):
    x1, y1 = box[0]
    x2, y2 = box[2]
    x, y = point
    return (x1 <= x <= x2) and (y1 <= y <= y2)


def structure_checkboxes(checkbox_pages):
    """Creates a dictionary with the information extracted from the checkboxes"""
    if len(checkbox_pages) < 2:
        raise ValueError(f"Pages length is {len(checkbox_pages)}. " "Expected 2 pages.")
    checkbox_indicator = dict()
    for page, centers in zip(checkbox_pages, box_centers):
        for box in page["elements"]:
            for center, (category, text) in centers.items():
                if point_in_box(center, box["coordinates"]):
                    if category not in checkbox_indicator:
                        checkbox_indicator[category] = {}
                    checkbox_indicator[category][text] = box["type"] == "Checked"

    structured_checkboxes = dict()
    for category, boxes in checkbox_indicator.items():
        if category != "referred":
            for text, checked in boxes.items():
                if checked:
                    if category in structured_checkboxes:
                        del structured_checkboxes[category]
                        break
                    structured_checkboxes[category] = text
    structured_checkboxes["referred"] = (
        "Yes" if checkbox_indicator["referred"]["Referred"] else "No"
    )

    return structured_checkboxes


def pipeline_api(
    file,
    file_content_type=None,
    filename=None,
):
    fixed_layouts = [get_fixed_layout(loc_d) for loc_d in field_locs]
    layout = get_layout(filename=filename, fixed_layouts=fixed_layouts)
    pages = partition_oer(layout=layout)["pages"]
    narrative = structure_oer(pages)

    file.seek(0)
    cb_layout = get_layout(file=file, model="checkbox")
    checkbox_pages = partition_oer(layout=cb_layout)["pages"]

    checkbox = structure_checkboxes(checkbox_pages)
    for key in ["referred", "comments", "supplementary_review", "performance"]:
        if "rater" in narrative and key in checkbox:
            narrative["rater"][key] = checkbox[key]
    if "senior_rater" in narrative and "potential" in checkbox:
        narrative["senior_rater"]["potential"] = checkbox["potential"]

    return narrative


class MultipartMixedResponse(StreamingResponse):
    CRLF = b"\r\n"

    def __init__(self, *args, content_type: str = None, **kwargs):
        super().__init__(*args, **kwargs)
        self.content_type = content_type

    def init_headers(self, headers: Optional[Mapping[str, str]] = None) -> None:
        super().init_headers(headers)
        self.boundary_value = secrets.token_hex(16)
        content_type = f'multipart/mixed; boundary="{self.boundary_value}"'
        self.raw_headers.append((b"content-type", content_type.encode("latin-1")))

    @property
    def boundary(self):
        return b"--" + self.boundary_value.encode()

    def _build_part_headers(self, headers: dict) -> bytes:
        header_bytes = b""
        for header, value in headers.items():
            header_bytes += f"{header}: {value}".encode() + self.CRLF
        return header_bytes

    def build_part(self, chunk: bytes) -> bytes:
        part = self.boundary + self.CRLF
        part_headers = {
            "Content-Length": len(chunk),
            "Content-Transfer-Encoding": "base64",
        }
        if self.content_type is not None:
            part_headers["Content-Type"] = self.content_type
        part += self._build_part_headers(part_headers)
        part += self.CRLF + chunk + self.CRLF
        return part

    async def stream_response(self, send: Send) -> None:
        await send(
            {
                "type": "http.response.start",
                "status": self.status_code,
                "headers": self.raw_headers,
            }
        )
        async for chunk in self.body_iterator:
            if not isinstance(chunk, bytes):
                chunk = chunk.encode(self.charset)
                chunk = b64encode(chunk)
            await send(
                {
                    "type": "http.response.body",
                    "body": self.build_part(chunk),
                    "more_body": True,
                }
            )

        await send({"type": "http.response.body", "body": b"", "more_body": False})


@router.post("/oer/v0.0.1/raters")
@limiter.limit(RATE_LIMIT)
async def pipeline_1(
    request: Request,
    files: Union[List[UploadFile], None] = File(default=None),
):
    content_type = request.headers.get("Accept")

    if isinstance(files, list) and len(files):
        if len(files) > 1:
            if content_type and content_type not in ["*/*", "multipart/mixed"]:
                return PlainTextResponse(
                    content=(
                        f"Conflict in media type {content_type}"
                        ' with response type "multipart/mixed".\n'
                    ),
                    status_code=status.HTTP_406_NOT_ACCEPTABLE,
                )

            def response_generator():
                for file in files:
                    _file = file.file

                    response = pipeline_api(
                        _file,
                        filename=file.filename,
                        file_content_type=file.content_type,
                    )
                    if type(response) not in [str, bytes]:
                        response = json.dumps(response)
                    yield response

            return MultipartMixedResponse(
                response_generator(),
            )
        else:
            file = files[0]
            _file = file.file

            response = pipeline_api(
                _file,
                filename=file.filename,
                file_content_type=file.content_type,
            )

            return response

    else:
        return PlainTextResponse(
            content='Request parameter "files" is required.\n',
            status_code=status.HTTP_400_BAD_REQUEST,
        )


@app.get("/healthcheck", status_code=status.HTTP_200_OK)
async def healthcheck(request: Request):
    return {"healthcheck": "HEALTHCHECK STATUS: EVERYTHING OK!"}


app.include_router(router)
